# Architecture Decision Record: Error Handling Strategy (ADR 001 - Revised)

## Date

2025-04-06 _(Original: 2025-04-06)_

## Status

Accepted

## Context

The CowGnition project is implementing a Model Context Protocol (MCP) server that integrates with Remember The Milk. For this implementation, we need a robust error handling strategy that provides:

1.  **Structured Error Types**: Domain-specific error types for different categories.
2.  **Context-Rich Errors**: Including relevant context data with all errors.
3.  **Consistent Wrapping**: Preserving the error chain.
4.  **Error Codes**: Consistent categorization, aligning with JSON-RPC 2.0 and application needs.
5.  **Stack Trace Preservation**: Capturing origin points for debugging.

Additionally, we need to ensure compliance with:

- JSON-RPC 2.0 error response format requirements (as used by MCP).
- Model Context Protocol (MCP) best practices for error reporting (e.g., distinguishing tool execution errors).
- MCP logging specification recommendations for detailed error reporting (`timestamp`, `level`, `message`, `service`, `request_id`, `connection_id`, `error_code`, `error_message`, `error_details`, `stack_trace`).

## Decision

1.  We will use the `github.com/cockroachdb/errors` package as our primary internal error handling library, combined with custom error types specific to our application domains (e.g., Transport, MCP, RTM Service).
2.  Validation errors (JSON parsing, Schema validation) identified by the **Validation Middleware (ADR 002)** will be immediately mapped to standard JSON-RPC errors (`-32700`, `-32600`, `-32602`) and returned, preventing further processing.
3.  Errors occurring _during the execution of MCP Tools_ (within `tools/call` handlers) will be handled differently: they will be caught within the handler and returned as part of a successful JSON-RPC response within the `CallToolResult` structure (e.g., setting `isError: true` and providing details in the `content`), allowing the LLM client to be aware of the tool's failure.
4.  All other internal application errors (unhandled exceptions, service integration failures, etc.) caught by central error handling middleware will be logged in detail server-side and mapped to appropriate JSON-RPC error codes (`-32603` or custom `-320xx` codes) for the client response.
5.  Structured logging (`slog` recommended) will be used, adhering to the MCP logging specification fields for errors.

Key implementation patterns:

- **Domain-Specific Error Types**: Create custom error types embedding standard error interfaces.
- **Context Attachment**: Use `errors.WithDetail()` to attach key-value pairs.
- **Stack Capture**: Use `errors.WithStack()` or standard constructors (`errors.New`, `errors.Wrap`).
- **Consistent Wrapping**: Always wrap errors when crossing domain boundaries or adding context.
- **Central Error Processing**: Implement middleware (after routing, before response serialization) that transforms internal application errors (not validation or tool errors handled earlier) into detailed logs and sanitized JSON-RPC responses.

## JSON-RPC & MCP Error Codes

The following standard JSON-RPC 2.0 error codes (referenced by MCP) will be used:

| Code             | JSON-RPC Meaning                    | Typical MCP Server Use Case                                                                  | Generated By                               |
| :--------------- | :---------------------------------- | :------------------------------------------------------------------------------------------- | :----------------------------------------- |
| -32700           | Parse Error                         | Invalid JSON received (Syntax error in the message)                                          | Initial JSON parsing (before middleware)   |
| -32600           | Invalid Request                     | Message is not a valid Request/Notification object (e.g., missing `jsonrpc`, `method`)       | Validation Middleware (Schema check)       |
| -32601           | Method Not Found                    | Requested MCP method (e.g., `resources/list`, `unknown/tool`) is not implemented/supported   | Router/Dispatcher or Validation Middleware |
| -32602           | Invalid Params                      | Method parameters are invalid (wrong type, missing required field for the _specific_ method) | Validation Middleware (Schema check)       |
| -32603           | Internal Error                      | Unspecified server-side error during handler processing (not validation or tool errors)      | Central Error Handler (Post-Handler)       |
| -32000 to -32099 | Implementation-defined server error | Custom _application_ errors (e.g., RTM API Failure, Resource Not Found, Access Denied)       | Central Error Handler (Post-Handler)       |

*Note: Errors during `tools/call` execution are generally *not* returned using these codes, but within the successful response's `CallToolResult`.*

## Consequences

### Positive

- Rich debugging information with stack traces and structured context.
- Consistent pattern for error context across the codebase.
- Clear mapping between internal errors and appropriate JSON-RPC error responses or `CallToolResult` errors.
- Compliance with MCP logging specifications for enhanced observability.
- Better developer experience when troubleshooting issues.
- Correctly handles tool execution errors as per MCP best practices (visible to LLM).

### Negative

- Learning curve for team members not familiar with `cockroachdb/errors`.
- Need for discipline in consistently applying the error handling patterns (especially distinguishing tool errors).
- Slightly increased dependency footprint (`cockroachdb/errors`).
- Requires careful mapping logic in central error handler and validation middleware.

## Implementation Guidelines

### Error Creation (Internal Application Errors)

Use `cockroachdb/errors` for detailed internal errors originating from handlers or services.

```go
// For new errors at source
func accessRTM() error {
    // ... rtm logic fails ...
    rtmErr := errors.New("RTM API request failed") // Original error
    appErr := &RTMError{ // Custom type for categorization/codes
        Code:    ErrRTMUnavailable,
        Message: "Could not connect to Remember The Milk",
    }
    // Add specific context and wrap
    errWithContext := errors.WithDetail(appErr, "rtm_endpoint", "https://api.rememberthemilk.com/services/rest/")
    return errors.Wrap(rtmErr, errWithContext.Error()) // Wrap maintains stack trace from rtmErr if needed
}

// For wrapping existing errors
if err != nil {
    // Add context specific to this layer
    return errors.Wrap(err, "failed during resource processing")
}
```

### Error Logging (Central Handler / Middleware)

Use structured logging (`slog` recommended). All handled application errors logged server-side must include:

- **Core Fields:** `timestamp`, `level` (e.g., "error"), `message` (human-readable summary).
- **MCP Context:** `service` (e.g., "mcp-server"), `request_id` (if available), `connection_id` (if available).
- **MCP Error Details:**
  - `error_code`: Internal application error code (e.g., `ErrRTMUnavailable`).
  * `error_message`: Internal error message (`err.Error()`).
  * `error_details`: Structured context captured via `errors.GetAllDetails(err)`.
  * `stack_trace`: Full stack trace obtained via `fmt.Sprintf("%+v", err)`.

_Logging for stdio transport should go to `stderr`._

### JSON-RPC Error Mapping (Central Handler / Middleware)

Internal _application_ errors (caught after handler execution) should be mapped to JSON-RPC 2.0 error responses sent to the client:

```go
func mapAppErrorToRPCError(err error) *RPCError {
    // Default
    rpcCode := -32603 // Internal Error
    userMsg := "An internal server error occurred."
    var data interface{} // Keep data nil unless safe context can be added

    // Example: Check for specific internal error types/codes
    var rtmErr *RTMError
    if errors.As(err, &rtmErr) {
        rpcCode = -32001 // Custom server error code for RTM issues
        userMsg = "Failed to communicate with RTM service."
        // Maybe add non-sensitive context?
        // data = map[string]string{"details": "RTM API unavailable"}
    }
    // ... other specific error mappings ...

    return &RPCError{
        Code:    rpcCode,
        Message: userMsg,
        Data:    data, // IMPORTANT: Sanitize data, do NOT leak internal details or stack traces!
    }
}

// In central handler:
rpcErr := mapAppErrorToRPCError(appErr)
errorRespBytes, _ := createJSONRPCErrorResponseBytes(reqID, rpcErr)
// Send errorRespBytes...
```

_Validation errors from middleware will generate `-32700`, `-32600`, `-32602` directly._

### Tool Error Handling (`tools/call` Handler)

Errors _during the execution_ of a tool must be caught within the handler and returned in the `CallToolResult`.

```go
func handleCalculateSum(ctx context.Context, params json.RawMessage) (*mcp.CallToolResult, error) {
    // ... decode params ...
    result, err := performCalculation(a, b)
    if err != nil {
        // Log the internal error server-side (using detailed logging strategy)
        log.ErrorContext(ctx, "Calculation tool failed", "error", err, "params", params)

        // Return error details within the CallToolResult for the LLM
        return &mcp.CallToolResult{
            IsError: true,
            Content: []mcp.Content{
                mcp.TextContent{Type: "text", Text: fmt.Sprintf("Calculation Error: %s", err.Error())},
                 // Optionally add structured error details if useful for the model
                // mcp.TextContent{Type: "text", Text: fmt.Sprintf("Details: Input was a=%v, b=%v", a, b)},
            },
        }, nil // Return nil error for the JSON-RPC layer itself
    }

    // Success case
    return &mcp.CallToolResult{
        IsError: false,
        Content: []mcp.Content{
             mcp.TextContent{Type: "text", Text: fmt.Sprintf("%v", result)},
        },
    }, nil
}

```

### Security Considerations

- Do not include sensitive information (keys, PII, internal paths) in any error details.
- Stack traces are strictly for server-side logs, never included in JSON-RPC error responses.
- Carefully sanitize any context included in the optional `data` field of JSON-RPC errors. Assume the client (and potentially the LLM via the client) might see it.

## Related Specifications

This decision aligns with:

1.  JSON-RPC 2.0 Specification
2.  MCP Specification (e.g., 2024-11-05 version for concepts)
3.  [MCP Logging Specification (2024-11-05)](https://spec.modelcontextprotocol.io/specification/2024-11-05/server/utilities/logging/)

## References

1.  [`cockroachdb/errors` Documentation](<[https://pkg.go.dev/github.com/cockroachdb/errors](https://pkg.go.dev/github.com/cockroachdb/errors)>)
2.  [JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)
3.  [MCP Specification - Concepts](https://www.google.com/search?q=https://modelcontextprotocol.io/docs/concepts/) (covers Tools error handling)
4.  [MCP Specification - Logging](https://spec.modelcontextprotocol.io/specification/2024-11-05/server/utilities/logging/)

---

### Document TODO: Assess following suggestions

Minor Points for Consideration:

Internal Error Codes: You mention custom -320xx codes and internal codes like ErrRTMUnavailable. It might be helpful to briefly state where these internal Go error codes/constants will be defined (e.g., in a dedicated ierr or domainerrors package) for consistency.
mapAppErrorToRPCError Complexity: As the application grows, the mapAppErrorToRPCError function could become complex with many if errors.As(err, ...) checks. Consider if a more structured approach (e.g., having custom error types implement an interface that provides their specific RPC mapping details) might be beneficial down the line, although the current approach is perfectly fine initially.
errors.Wrap Example Clarification: The accessRTM example demonstrates wrapping, but the line errors.Wrap(rtmErr, errWithContext.Error()) might be slightly less common than letting Wrap manage the message combination. Often, you'd wrap the underlying error with a new context message (errors.Wrap(rtmErr, "failed to access RTM API")) or use constructors like errors.WrapWithDetails if available/suitable in cockroachdb/errors. The current example works, but just double-check it produces the desired combined error message and stack trace elegantly. The core idea of wrapping is correctly captured.
Tool Error Logging Consistency: The example correctly logs the tool error server-side before constructing the CallToolResult. Ensure this pattern is consistently applied across all tools/call implementations.
